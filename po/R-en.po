msgid "describe canned"
msgstr
"describe.<<model name>> <- function () {\n"
"package <- list(name=\"stats\",\n"
"version=\".9\"\n"
")\n"
"\n"
"# edit the below line to add a description\n"
"# to this zelig model\n"
"description <- \"a zelig model\"\n"
"\n"
"# edit the below with information about\n"
"# the model that this zelig module is based on\n"
"# the citation year may differ than the auto-generated one\n"
"list(category = \"\",\n"
"authors = \"<<author>>\",\n"
"year = <<year>>,\n"
"description = description,\n"
"package = package,\n"
"parameters=list(list())\n"
")\n"
"}"


msgid "describe how-to"
msgstr
"# HOW-TO WRITE A DESCRIBE FUNCTION\n"
"# ================================\n"
"# 1. Fill in the \"description\" variable with a *short*\n"
"#    description of the model. e.g. \"multinomial probit model\"\n"
"# 2. Fill in the return-value for \"category\"\n"
"# 3. Fill in the return-value for \"authors\" with either:\n"
"#    i.  <<author name>>, or\n"
"#    ii. c(<<author 1>>, <author 2>>, <<author 3>>, ...)\n"
"# 4. Fill in the return-value for \"year\"\n"
"# 5. <optional> Fill in the package variable"


msgid "describe credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# .<<model>>.R\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: describe.<<model>> generates citation information\n"
"#       for the zelig model <<model>>"


msgid "zelig2 canned"
msgstr
"zelig2<<model name>> <- function (formula, model, data, M, ...) {\n"
"# this file acts as an interface to the original model\n"
"# the return (\"mf\") is a function call that zelig will later invoke\n"
"# in order to process the specified data set\n"
"#\n"
"# any parameters unnecessary to the model\n"
"# should be set to NULL (e.g. mf$M, mf$robust, etc...)\n"
"\n"
"mf <- match.call(expand.dots=T)\n"
"mf$M <- mf$robust <- NULL\n"
"mf[[1]] <- <<model function>>\n"
"mf$model <- NULL\n"
"mf$data <- data\n"
"mf$formula <- formula\n"
"as.call(mf)\n"
"}"


msgid "zelig2 how-to"
msgstr
"# 0. the zelig2 function acts as an interface between\n"
"#    the existing model and the zelig module that is\n"
"#    being created.\n"
"# 1. construct a call object containing all the parameters\n"
"#    passed into \"zelig2<<model name>>\"\n"
"# 2. remove all parameters that will not make sense within\n"
"#    the original model (in the demo code, e.g. robust, M, etc.)\n"
"# 3. re-assign the call object's first entry to the name of the\n"
"#    model that must be called.\n"
"#    This step is crucial, as it is how your model invokes the\n"
"#    pre-existing model's name\n"
"# 4. attach the data frame (mf$data <- data)\n"
"# 5. return the call (as a call)\n"
"#\n"
"# NOTE: the returned value is going to be evaluated, and -\n"
"#       as a result - call the pre-existing model.  Any\n"
"#       parameters passed to the original zelig function\n"
"#       will be forwarded to the model unless set to NULL\n"
"#\n"
"#\n"
"# NOTE: THIS FUNCTION IS INVOKED BY THE ZELIG FUNCTION\n"
"#       (NOT THE USER)\n"
"#\n"
"# call order: zelig -> zelig2<<model name>>\""


msgid "zelig2 credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# zelig2<<model>>.R\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: re-interprets parameters passed into zelig as\n"
"#       legal parameters to pass into <<model function>>"


msgid "zelig3 canned"
msgstr
"zelig3<<model name>> <- function (res, ...) {\n"
"class(res) <- c(\"<<model name>>\", class(res))\n"
"\n"
"# give it a terms object\n"
"if (is.null(res$terms))\n"
"res$terms <- terms(res$call$formula)\n"
"\n"
"# return\n"
"res\n"
"}"


msgid "zelig3 how-to"
msgstr
"# HOW-TO WRITE A ZELIG3 FUNCTION\n"
"# ==============================\n"
"# 0. zelig3 functions act as in-betweens between\n"
"#    the zelig2 function and the zelig and sim function.\n"
"#    That is, after the model runs its initial computations,\n"
"#    it is often important to cast the result as an object of\n"
"#    the class which it is named after.  This is crucial to\n"
"#    ensure that setx invokes the correct method\n"
"# 1. set the class of the res passed into with the line:\n"
"#      class(res) <- class(\"<<model name>>\", class(res))\n"
"# 2. return the obj (with class newly extended)\n"
"#\n"
"# NOTE: if the class \"<<model name>>\" is not added, the function\n"
"#       setx.default will be used, which may have unexpected\n"
"#       results"


msgid "zelig3 credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# zelig3<<model>>.R\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: not always necessary, but is useful to cast data\n"
"#       the result of a zelig2* call into whatever data-type\n"
"#       we want our setx function to work with"


msgid "setx canned"
msgstr
"setx.<<model name>> <- function(obj, data=NULL, ...) {\n"
"# send to default\n"
"res <- setx.default(obj, ...)\n"
"\n"
"# cast as appropriate data-type, then return\n"
"class(res) <- \"setx.<<model name>>\"\n"
"\n"
"# attach data frame here, if the model\n"
"# requires sophisticated number-crunching\n"
"# after setx is called\n"
"# if not, remove the below line\n"
"if (!is.null(data)) {\n"
"res$data <- data\n"
"}\n"
"\n"
"res\n"
"}"


msgid "setx how-to"
msgstr
"# HOW-TO WRITE A SETX FUNCTION\n"
"# ============================\n"
"# 0. For most purposes setx.default will compute\n"
"#    correctly values of interest, which are needed\n"
"#    to compute the quantities of interest.  However,\n"
"#    some models will not provide data in the correct\n"
"#    fashion, etc. (e.g. computing a covariance matrix\n"
"#    of the explanatory variables may not make sense\n"
"#    or be relevant for certain models)\n"
"# 1. parameters are passed in as a zelig model and potentially\n"
"#    a new data-set.  The new data-set is used in place of the\n"
"#    original one that was passed into zelig.  This\n"
"# 2. the result of the setx function should be of class\n"
"#    \"setx.<<model name>>\"\n"
"#    this is important, because it ensures that the correct\n"
"#    qi function and sim function are called\n"
"# 3. <optional> the data frame used to compute this setx may\n"
"#    be attached with the line\n"
"#      res$data <- data\n"
"#    if the sim function needs to make further computations\n"
"#    if this is not the case, please omit that line"


msgid "setx credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# setx.<<model name>>\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: produces data based on the explanatory variables\n"
"#       in the model (set by user, not developer)"


msgid "sim canned"
msgstr
"sim.<<model name>> <- function(obj,\n"
"x=NULL,\n"
"x1=NULL,\n"
"num=c(1000, 100),\n"
"prev = NULL,\n"
"cond.data = NULL, ...\n"
") {\n"
"# error-catching\n"
"if (is.null(x))\n"
"stop(\"Error: x cannot be NULL\")\n"
"\n"
"# simulate qi's for x\n"
"# invoke qi.<model name>\n"
"res <- qi.<<model name>>(obj, x=x, x1=x1)\n"
"\n"
"# change call name\n"
"obj$call[[1]] <- as.name(\"sim\")\n"
"\n"
"\n"
"# append\n"
"res$call <- match.call(expand.dots=T)\n"
"res$zelig.call <- obj$call\n"
"res$par <- NA\n"
"res$obj <- obj\n"
"\n"
"# change class so correct summary/print function\n"
"# can be called\n"
"class(res) <- \"sim.<<model name>>\"\n"
"\n"
"res\n"
"}"


msgid "sim how-to"
msgstr
"# HOW-TO WRITE A SIM FUNCTION\n"
"# ===========================\n"
"# 0. The sim function invokes the qi function.\n"
"#    Then, returns the quantities of interests\n"
"#    alongside a host of other relevant data, that\n"
"#    is presented along with summary and print\n"
"# 1. importantly, sim should always have the line:\n"
"#      res <- qi(obj, x=x, x1=x1)\n"
"#    this enesure that the qi's are computed with the\n"
"#    exact parameters that enter the sim function itself\n"
"# 2. the call to sim and the call should be returned along\n"
"#    with the quantities of interest (qi.stat) and their\n"
"#    titles (qi.name)\n"
"# 3. the returned object should have class type:\n"
"#     \"sim.<<model name>>:"


msgid "sim credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# sim.<<model>>.R\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: simulates quantities of interest, then arranges\n"
"#       the data in an easily interprettable manner.\n"
"#       invokes qi.<<model>>.R"


msgid "sim.setx canned"
msgstr
"sim.setx.<<model name>> <- function (obj, x, ...) {\n"
"# this function exists so that if\n"
"# sim(obj) and sim(obj, x) should have radically\n"
"# different behavior, we will be able to place them\n"
"# in seperate files easily\n"
"sim.<<model name>>(obj, x, ...)\n"
"}"


msgid "sim.setx how-to"
msgstr
"# HOW-TO WRITE A SIM.SETX FILE\n"
"# ============================\n"
"# 0. sim.setx functions offer alternative ways\n"
"#    to simulate quantities of interest.  That is,\n"
"#    sim functions are called in this fashion\n"
"#      sim(zelig.out)\n"
"#\n"
"#    while sim.setx functs are called as:\n"
"#      sim(zelig.out, x)\n"
"#    or\n"
"#      sim(zelig.out, x, x1)\n"
"#\n"
"#    this allows the developer to separate\n"
"#    the different types of simulation algorithms\n"
"#    that may exist for his or her model\n"
"#\n"
"#    if the model simulates quantities of interest\n"
"#    identically to that of the standard sim function\n"
"#    it should then only contain the line:\n"
"#      sim.<<model name>>(obj, x, ...)\n"
"#\n"
"# 1. invoke qi with\n"
"#      qi(obj, x=x, x=x1)\n"
"#\n"
"#    do relevant computation on the return quantities\n"
"#    of interest, and attach relevant data that needs\n"
"#    to be passed to print and summary functions"


msgid "sim.setx credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# sim.setx.<<model>>.R\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: simulates qi's when additional explanatory\n"
"#       information is provided.  usually simply\n"
"#       invokes the method specified in sim.<<model>>.R"


msgid "summary.sim canned"
msgstr
"summary.sim.<<model name>> <- function(obj, ...) {\n"
"# set important summary objects\n"
"# zelig models always have qi.stat, and qi.name\n"
"# elements\n"
"res <- list(model=\"mprobit\",\n"
"qi.stat   = obj$qi.stat,\n"
"qi.name    = obj$qi.name,\n"
"original   = obj$obj,\n"
"call       = obj$call,\n"
"zelig.call = obj$zelig.call\n"
")\n"
"\n"
"# cast as class\n"
"class(res) <- \"summary.sim.<<model name>>\"\n"
"\n"
"res\n"
"}"


msgid "summary.sim how-to"
msgstr
"# HOW TO WRITE A SUMMARY.SIM FUNCTION\n"
"# ===================================\n"
"# 0. summary.sim functions exclusively return\n"
"#    a list of important data, *summarizing*\n"
"#    important features of the result of the sim\n"
"#    function\n"
"# 1. like summaries of most objects, the result should\n"
"#    contain a reference to the call that created it,\n"
"#    information on the class-type, etc.:\n"
"#      list(call = obj$call,\n"
"#           zelig.call = obj$zelig.call,\n"
"#           ...)\n"
"# 2. importantly, summary.sim must return a qi.stat\n"
"#    and a qi.name data object.  the indices of these\n"
"#    objects must have the same values for consistency\n"
"#    that is, names(qi.stat) == names(qi.name)\n"
"#    the return should resemble:\n"
"#      list(\n"
"#           qi.stat    = obj$qi.stat,\n"
"#           qi.name    = obj$qi.name,\n"
"#           call       = obj$call,\n"
"#           zelig.call = obj$zelig.call\n"
"#           ...)"


msgid "summary.sim credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# summary.sim.<<model>>.R\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: returns a list of data summarizing the sim object\n"
"#       should always include qi.stat, qi.name entry"


msgid "print.summary.sim canned"
msgstr
"print.summary.sim.<<model name>> <- function (obj, digits=F, print.x=F, ...) {\n"
"# prints typically have qi, and qi.names defined as part of the summary object\n"
"if (is.null(obj$qi.stat) || is.null(obj$qi.name)) {\n"
"stop(\"Error: \")\n"
"}\n"
"\n"
"# warn if name lists do not match\n"
"if (any(sort(names(obj$qi.stat)) != sort(names(obj$qi.name)))) {\n"
"warning(\"warning: quantities of interest do not match its name list\")\n"
"}\n"
"\n"
"print(obj$original)\n"
"\n"
"for (key in names(obj$qi.stat)) {\n"
"# value\n"
"val <- obj$qi.stat[[key]]\n"
"\n"
"# pass-by conditions\n"
"if (is.na(val) || (is.list(val) && !length(val)) || is.null(val))\n"
"next\n"
"\n"
"# print the title of the qi\n"
"s <- gsub(\"\\\\s+$\", \"\", obj$qi.name[[key]])\n"
"message(s)\n"
"message(rep(\"=\", min(nchar(s), 30)))\n"
"\n"
"# print the qi (should be a simple data-type, such as matrix or float)\n"
"print(val)\n"
"\n"
"# line-feed\n"
"message()\n"
"}\n"
"\n"
"# return invisibly\n"
"invisible(obj)\n"
"}"


msgid "print.summary.sim how-to"
msgstr
"# HOW TO WRITE A PRINT.SUMMARY.SIM FUNCTION\n"
"# =========================================\n"
"# 0. print.summary functions typically display the result\n"
"#    from a summary object (a list) in an organized fashion\n"
"#    with various text-formatting.\n"
"# 1. for most purpose the default print function (below) should\n"
"#    work, however, various formatting, etc. can be added typically\n"
"#    without any impact on the operation of the program"


msgid "print.summary.sim credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# .<<model>>.R\n"
"# auto-generated by zkeleton, written by Matt Owen\n"
"# info: print.summary.sim.<<model>>.R outputs summary\n"
"#       information from the zelig model <<model>>"


msgid "qi canned"
msgstr
"# @obj:    zelig object\n"
"# @simpar: parameters passed to the qi\n"
"# return:  qi list (qi.stat) and qi.names list (qi.name)\n"
"\n"
"# NOTE THIS FILE MUST ALWAYS BE EDITED!!!!\n"
"# IT IS THE MOST IMPORTANT COMPONENT TO\n"
"# ANY ZELIG MODULE\n"
"qi.<<model name>> <- function(obj, simpar=NULL, x, x1=NULL, y=NULL) {\n"
"# initialize values that necessarily must be\n"
"# returned.\n"
"qi.stat <- list()\n"
"qi.name <- list()\n"
"\n"
"\n"
"# add entries to qi.stat and qi.name\n"
"# in the end, names(qi.stat) should == names(qi.name)\n"
"# so that printing can be handled by the auto-generated\n"
"# function\n"
"\n"
"# ...\n"
"\n"
"\n"
"# qi computation must be written by the developer,\n"
"# as it is impossible to tell automatically what is\n"
"# the statistic of interest (or how to compute it)\n"
"\n"
"# ...\n"
"\n"
"\n"
"# compute the quantities of interest\n"
"# of this model\n"
"list(qi.stat=qi.stat,\n"
"qi.name=qi.name\n"
")\n"
"}"


msgid "qi how-to"
msgstr
"# HOW-TO WRITE A QI FILE\n"
"# ======================\n"
"# qi functions are the heart of any zelig module.\n"
"# The qi function is passed information from the setx\n"
"# function (via x, x1), parameters (simpar), and the\n"
"# original zelig model (obj or object)\n"
"# The developer (you) then writes the software that he/she\n"
"# believes produces a significant quantity of interest.\n"
"# The result should always be returned in the fashion\n"
"# list(qi.stat=qi.stat\n"
"#      qi.name=qi.name\n"
"#     )\n"
"# where qi.stat is a list of qi.stat and qi.name have the form\n"
"# qi.stat <- list(qi.1 = <<qi.1>>,\n"
"#                 qi.2 = <<qi.2>>,\n"
"#                 qi.3 = <<qi.3>>,\n"
"#                 ...\n"
"#                 )\n"
"#\n"
"# qi.name <- list(qi.1 = <<qi.1 name>>,\n"
"#                 qi.2 = <<qi.2 name>>,\n"
"#                 qi.3 = <<qi.3 name>>,\n"
"#                 ...\n"
"#                 )\n"
"#\n"
"# qi.1, qi.2, etc. should be named in an easy to comprehend manner\n"
"# the indices of qi.stat and qi.name (qi.1, qi.2, etc.) should match,\n"
"# otherwise a warning will be displayed during the print stage"


msgid "qi credit"
msgstr
"# @author: <<author>>\n"
"# @date:   <<date>>\n"
"# qi.<<model name>>, auto-generated by zkeleton, written by Matt Owen\n"
"# ===========================\n"
"# info: produced quantities of interest for zelig model <<model>>"


